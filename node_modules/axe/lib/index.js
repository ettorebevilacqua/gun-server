"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// eslint-disable-next-line import/no-unassigned-import
require('console-polyfill');

var boolean = require('boolean');

var cuid = require('cuid');

var formatSpecifiers = require('format-specifiers');

var isError = require('iserror');

var omit = require('omit.js');

var parseAppInfo = require('parse-app-info');

var parseErr = require('parse-err');

var safeStringify = require('fast-safe-stringify');

var superagent = require('superagent');

var format = require('format-util');

var pkg = require('../package.json');

var omittedLoggerKeys = ['config', 'log'];
var levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];
var endpoint = 'https://api.cabinjs.com';
var env = process.env.NODE_ENV || 'development';
var levelError = "`level` invalid, must be: ".concat(levels.join(', ')); // <https://stackoverflow.com/a/43233163>

function isEmpty(value) {
  return value === undefined || value === null || _typeof(value) === 'object' && Object.keys(value).length === 0 || typeof value === 'string' && value.trim().length === 0;
}

function isNull(val) {
  return val === null;
}

function isUndefined(val) {
  return typeof val === 'undefined';
}

function isObject(val) {
  return _typeof(val) === 'object' && val !== null && !Array.isArray(val);
}

function isString(val) {
  return typeof val === 'string';
}

function isFunction(val) {
  return typeof val === 'function';
}

function isBoolean(val) {
  return typeof val === 'boolean';
}

var Axe =
/*#__PURE__*/
function () {
  function Axe() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Axe);

    this.config = Object.assign({
      key: '',
      endpoint: endpoint,
      headers: {},
      timeout: 5000,
      retry: 3,
      showStack: process.env.SHOW_STACK ? boolean(process.env.SHOW_STACK) : true,
      showMeta: process.env.SHOW_META ? boolean(process.env.SHOW_META) : true,
      silent: false,
      logger: console,
      name: false,
      level: 'info',
      levels: ['info', 'warn', 'error', 'fatal'],
      capture: process.browser ? false : env === 'production',
      callback: false,
      appInfo: process.env.APP_INFO ? boolean(process.env.APP_INFO) : true
    }, config);
    this.appInfo = this.config.appInfo ? isFunction(parseAppInfo) ? parseAppInfo() : false : false;
    this.log = this.log.bind(this); // inherit methods from parent logger

    var methods = Object.keys(this.config.logger).filter(function (key) {
      return omittedLoggerKeys.indexOf(key) === -1;
    });

    for (var i = 0; i < methods.length; i++) {
      this[methods[i]] = this.config.logger[methods[i]];
    } // bind helper functions for each log level


    var _loop = function _loop(_i) {
      _this[levels[_i]] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this.log.apply(_this, _toConsumableArray([levels[_i]].concat([].slice.call(args))));
      };
    };

    for (var _i = 0; _i < levels.length; _i++) {
      _loop(_i);
    } // we could have used `auto-bind` but it's not compiled for browser


    this.setLevel = this.setLevel.bind(this);
    this.setName = this.setName.bind(this);
    this.setCallback = this.setCallback.bind(this); // set the logger name

    if (this.config.name) this.setName(this.config.name); // set the logger level

    this.setLevel(this.config.level); // aliases

    this.err = this.error;
    this.warning = this.warn;
  }

  _createClass(Axe, [{
    key: "setCallback",
    value: function setCallback(callback) {
      this.config.callback = callback;
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      if (!isString(level) || levels.indexOf(level) === -1) throw new Error(levelError); // support signale logger and other loggers that use `logLevel`

      if (isString(this.config.logger.logLevel)) this.config.logger.logLevel = level;else this.config.logger.level = level; // adjusts `this.config.levels` array
      // so that it has all proceeding (inclusive)

      this.config.levels = levels.slice(levels.indexOf(level));
    }
  }, {
    key: "setName",
    value: function setName(name) {
      if (!isString(name)) throw new Error('`name` must be a String'); // support signale logger and other loggers that use `scope`

      if (isString(this.config.logger.scope)) this.config.logger.scope = name;else this.config.logger.name = name;
    } // eslint-disable-next-line complexity

  }, {
    key: "log",
    value: function log(level, message, meta) {
      var _this2 = this;

      var originalArgs = [level, message];
      if (!isUndefined(meta)) originalArgs.push(meta);

      for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        args[_key2 - 3] = arguments[_key2];
      }

      originalArgs = originalArgs.concat([].slice.call(args));
      var config = this.config;
      var modifier = 0;
      if (level === 'warning') level = 'warn';
      if (level === 'err') level = 'error';

      if (isError(level)) {
        meta = message;
        message = level;
        level = 'error';
      } else if (!isString(level) || levels.indexOf(level) === -1) {
        meta = message;
        message = level;
        level = 'info';
        modifier = -1;
      } // if there are four or more args
      // then infer to use util.format on everything


      if (originalArgs.length >= 4 + modifier) {
        message = format.apply(void 0, _toConsumableArray(originalArgs.slice(1 + modifier)));
        meta = {};
      } else if (originalArgs.length === 3 + modifier && isString(message) && formatSpecifiers.filter(function (t) {
        return message.indexOf(t) !== -1;
      }).length > 0) {
        // otherwise if there are three args and if the `message` contains
        // a placeholder token (e.g. '%s' or '%d' - see above `formatSpecifiers` variable)
        // then we can infer that the `meta` arg passed is used for formatting
        message = format(message, meta);
        meta = {};
      } else if (!isError(message)) {
        if (isError(meta)) {
          meta = {
            err: parseErr(meta)
          }; // } else if (!isPlainObject(meta) && !isUndefined(meta) && !isNull(meta)) {
        } else if (!isObject(meta) && !isUndefined(meta) && !isNull(meta)) {
          // if the `meta` variable passed was not an Object then convert it
          message = format(message, meta);
          meta = {};
        } else if (!isString(message)) {
          // if the message is not a string then we should run `util.format` on it
          // assuming we're formatting it like it was another argument
          // (as opposed to using something like fast-json-stringify)
          message = format(message);
        }
      } // if (!isPlainObject(meta)) meta = {};


      if (!isObject(meta)) meta = {};
      var err;

      if (isError(message)) {
        err = message;
        if (!isObject(meta.err)) meta.err = parseErr(err);
        var _message = message;
        message = _message.message;
      } else if (isError(meta.err)) {
        err = meta.err;
      } // omit `callback` from `meta` if it was passed


      var callback = isFunction(config.callback) && (!isBoolean(meta.callback) || meta.callback);
      meta = omit(meta, ['callback']); // set default level on meta

      meta.level = level; // add `app` object to metadata

      if (this.appInfo) meta.app = this.appInfo; // set the body used for returning with and sending logs
      // (and also remove circular references)

      var body = safeStringify({
        message: message,
        meta: meta
      }); // send to Cabin or other logging service here the `message` and `meta`

      if (config.capture && config.levels.indexOf(level) !== -1 && (!isError(err) || !err._captureFailed)) {
        // if the user didn't specify a key
        // and they are using the default endpoint
        // then we should throw an error to them
        if (config.endpoint === endpoint && !config.key) throw new Error("Cabin API key required (e.g. `{ key: 'YOUR-CABIN-API-KEY' })`)\n<https://cabinjs.com>"); // capture the log over HTTP

        var req = superagent.post(config.endpoint).set('X-Request-Id', cuid()).timeout(config.timeout);
        if (!process.browser) req.set('User-Agent', "axe/".concat(pkg.version)); // basic auth (e.g. Cabin API key)

        if (config.key) req.auth(config.key); // set headers if any

        if (!isEmpty(config.headers)) req.set(config.headers);
        req.retry(config.retry).type('application/json').send(body).end(function (err) {
          if (err) {
            err._captureFailed = true;

            _this2.config.logger.error(err);
          }
        });
      } // custom callback function (e.g. Slack message)


      if (callback) config.callback(level, message, meta); // suppress logs if it was silent

      if (config.silent) return body; // return early if it is not a valid logging level

      if (config.levels.indexOf(level) === -1) return body; //
      // determine log method to use
      //
      // if we didn't pass a level as a method
      // (e.g. console.info), then we should still
      // use the logger's `log` method to output
      //
      // and fatal should use error (e.g. in browser)
      //

      var method = level;
      if (modifier === -1) method = 'log';else if (level === 'fatal') method = 'error'; // if there was meta information then output it

      var omitted = omit(meta, ['level', 'err']); // show stack trace if necessary (along with any metadata)

      if (method === 'error' && isError(err) && config.showStack) {
        if (!config.showMeta || isEmpty(omitted)) this.config.logger.error(err);else this.config.logger.error(err, omitted);
      } else if (!config.showMeta || isEmpty(omitted)) {
        this.config.logger[method](message);
      } else {
        this.config.logger[method](message, omitted);
      } // return the parsed body in case we need it


      return body;
    }
  }]);

  return Axe;
}();

module.exports = Axe;